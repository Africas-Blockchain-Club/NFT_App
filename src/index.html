<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DIY AA NFT Minting</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.15.0/ethers.umd.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f8ff;
            color: #333;
        }
        header {
            text-align: center;
            margin-bottom: 30px;
        }
        h1 {
            color: #4a6cf7;
            margin-bottom: 10px;
        }
        .card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        .status {
            padding: 12px;
            border-radius: 8px;
            margin: 10px 0;
            font-weight: 500;
        }
        .status.connected {
            background-color: #e6f4ea;
            color: #137333;
        }
        .status.error {
            background-color: #fce8e6;
            color: #c5221f;
        }
        .status.pending {
            background-color: #e8f0fe;
            color: #1a73e8;
        }
        button {
            background-color: #4a6cf7;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            margin: 5px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #3a5cd8;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        .nft-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        .nft-card {
            background: #f0f4ff;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
        }
        .network-info {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 15px 0;
        }
        .network-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
        }
        .network-connected {
            background-color: #0f0;
        }
        .network-disconnected {
            background-color: #f00;
        }
    </style>
</head>
<body>
    <header>
        <h1>DIY Account Abstraction NFT Minting</h1>
        <p>Experience gasless transactions with ERC-4337 AA</p>
    </header>

    <div class="card">
        <h2>Connect Your Wallet</h2>
        <div class="network-info">
            <span id="networkIndicator" class="network-indicator network-disconnected"></span>
            <span id="networkStatus">Not connected to Scroll Sepolia</span>
        </div>
        <button id="connectBtn">Connect Wallet</button>
        <div id="connectionStatus" class="status"></div>
    </div>

    <div class="card">
        <h2>Mint Your NFT</h2>
        <p>Mint a free NFT using Account Abstraction (gasless)</p>
        <button id="mintBtn" disabled>Mint Free NFT</button>
        <div id="mintStatus" class="status"></div>
    </div>

    <div class="card">
        <h2>Your NFT Collection</h2>
        <div id="nfts" class="nft-container">
            <p>No NFTs yet. Connect your wallet and mint one!</p>
        </div>
    </div>

    <script>
        // Configuration
        const SCROLL_RPC_URL = "https://sepolia-rpc.scroll.io/";
        const SCROLL_CHAIN_ID = "0x8274F"; // Scroll Sepolia
        const SCROLL_CHAIN_NAME = "Scroll Sepolia";
        const CONTRACT_ADDRESS = ""; // Replace with your contract
        const BUNDLER_URL = "https://bundler.zerodev.app/api/v2/aa/YOUR_PROJECT_ID"; // Replace with your ZeroDev project ID
        const ENTRY_POINT = "0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789";
        const FACTORY = "0x9406Cc6185a346906296840746125a0E44976454";

        // NFT Contract ABI
        const NFT_ABI = [
            "function safeMint(address to) public",
            "function balanceOf(address owner) view returns (uint256)",
            "function ownerOf(uint256 tokenId) view returns (address)",
            "function tokenURI(uint256 tokenId) view returns (string memory)"
        ];

        // Global variables
        let provider, signer, nftContract, diyAA, bundlerClient;

        // DOM elements
        const connectBtn = document.getElementById('connectBtn');
        const mintBtn = document.getElementById('mintBtn');
        const networkStatus = document.getElementById('networkStatus');
        const networkIndicator = document.getElementById('networkIndicator');
        const connectionStatus = document.getElementById('connectionStatus');
        const mintStatus = document.getElementById('mintStatus');
        const nftsContainer = document.getElementById('nfts');

        // Event listeners
        connectBtn.addEventListener('click', connectWallet);
        mintBtn.addEventListener('click', mintWithDIYAA);

        // DIY Account Abstraction Class
        class DIYAccountAbstraction {
            constructor(provider, factoryAddress, entryPointAddress) {
                this.provider = provider;
                this.factory = factoryAddress;
                this.entryPoint = entryPointAddress;
                this.smartAccount = null;
            }
            
            async createSmartAccount() {
                const signer = await this.provider.getSigner();
                const ownerAddress = await signer.getAddress();
                
                // For demo purposes, create a deterministic address
                const salt = ethers.hexlify(ethers.toUtf8Bytes("demo-salt"));
                const predictedAddress = await this.predictAddress(ownerAddress, salt);
                
                this.smartAccount = {
                    address: predictedAddress,
                    owner: ownerAddress,
                    salt: salt,
                    isDeployed: false
                };
                
                return this.smartAccount;
            }
            
            async predictAddress(ownerAddress, salt) {
                // Simple deterministic address prediction for demo
                const hash = ethers.keccak256(ethers.toUtf8Bytes(ownerAddress + salt));
                return "0x" + hash.slice(2, 42); // First 20 bytes
            }
            
            async createUserOp(target, data, value = 0) {
                if (!this.smartAccount) throw new Error("Smart account not created");
                
                // Get current gas prices
                const feeData = await this.provider.getFeeData();
                
                return {
                    sender: this.smartAccount.address,
                    nonce: 0, // Simple nonce for demo
                    initCode: await this.getInitCode(),
                    callData: await this.encodeCallData(target, data, value),
                    callGasLimit: 200000,
                    verificationGasLimit: 100000,
                    preVerificationGas: 50000,
                    maxFeePerGas: feeData.maxFeePerGas || ethers.parseUnits("10", "gwei"),
                    maxPriorityFeePerGas: feeData.maxPriorityFeePerGas || ethers.parseUnits("2", "gwei"),
                    paymasterAndData: "0x",
                    signature: "0x"
                };
            }
            
            async getInitCode() {
                if (this.smartAccount.isDeployed) return "0x";
                
                // Encode factory call to create account
                const factoryInterface = new ethers.Interface([
                    "function createAccount(address owner, uint256 salt) returns (address)"
                ]);
                
                const initCallData = factoryInterface.encodeFunctionData("createAccount", [
                    this.smartAccount.owner,
                    this.smartAccount.salt
                ]);
                
                return ethers.concat([this.factory, initCallData]);
            }
            
            async encodeCallData(target, data, value) {
                // Encode execution call for smart account
                const accountInterface = new ethers.Interface([
                    "function execute(address to, uint256 value, bytes calldata data) external"
                ]);
                
                return accountInterface.encodeFunctionData("execute", [
                    target,
                    value,
                    data
                ]);
            }
            
            async signUserOp(userOp) {
                // For demo, we'll simulate signing
                userOp.signature = "0xsimulated_signature_for_demo";
                return userOp;
            }
        }

        // DIY Bundler Client Class
        class DIYBundlerClient {
            constructor(bundlerUrl, chainId) {
                this.bundlerUrl = bundlerUrl;
                this.chainId = chainId;
            }
            
            async sendUserOp(userOp, entryPoint) {
                // Send to professional bundler
                const response = await fetch(this.bundlerUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        jsonrpc: '2.0',
                        id: 1,
                        method: 'eth_sendUserOperation',
                        params: [userOp, entryPoint]
                    })
                });
                
                const result = await response.json();
                return result.result; // Returns userOpHash
            }
            
            async getUserOpReceipt(userOpHash) {
                // Check UserOperation status
                const response = await fetch(this.bundlerUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        jsonrpc: '2.0',
                        id: 1,
                        method: 'eth_getUserOperationReceipt',
                        params: [userOpHash]
                    })
                });
                
                return await response.json();
            }
        }

        // Connect Wallet function
        async function connectWallet() {
            if (typeof window.ethereum === 'undefined') {
                updateStatus(connectionStatus, "Please install MetaMask!", "error");
                return;
            }

            try {
                updateStatus(connectionStatus, "Connecting to Scroll Sepolia...", "pending");
                
                // Request account access
                await window.ethereum.request({ method: 'eth_requestAccounts' });
                
                // Check and switch to Scroll Sepolia
                await switchToScrollSepolia();
                
                // Initialize providers and contracts
                provider = new ethers.BrowserProvider(window.ethereum);
                signer = await provider.getSigner();
                nftContract = new ethers.Contract(CONTRACT_ADDRESS, NFT_ABI, signer);
                
                // Initialize DIY AA
                diyAA = new DIYAccountAbstraction(provider, FACTORY, ENTRY_POINT);
                await diyAA.createSmartAccount();
                
                // Initialize bundler client
                bundlerClient = new DIYBundlerClient(BUNDLER_URL, parseInt(SCROLL_CHAIN_ID, 16));
                
                // Update UI
                updateStatus(connectionStatus, "Connected to Scroll Sepolia! DIY AA Ready!", "connected");
                mintBtn.disabled = false;
                networkStatus.textContent = "Connected to Scroll Sepolia";
                networkIndicator.className = "network-indicator network-connected";
                
                // Load NFTs
                await loadNFTs();
                
            } catch (error) {
                console.error("Connection error:", error);
                updateStatus(connectionStatus, "Error: " + error.message, "error");
            }
        }

        // Mint with DIY AA
        async function mintWithDIYAA() {
            try {
                updateStatus(mintStatus, "Creating UserOperation...", "pending");
                
                const address = await signer.getAddress();
                const mintData = nftContract.interface.encodeFunctionData("safeMint", [address]);
                
                // 1. DIY: Create UserOperation
                const userOp = await diyAA.createUserOp(CONTRACT_ADDRESS, mintData, 0);
                
                updateStatus(mintStatus, "Signing UserOperation...", "pending");
                
                // 2. DIY: Sign (simplified for demo)
                const signedOp = await diyAA.signUserOp(userOp);
                
                updateStatus(mintStatus, "Sending to bundler...", "pending");
                
                // 3. Send to professional bundler (free)
                const userOpHash = await bundlerClient.sendUserOp(signedOp, ENTRY_POINT);
                
                updateStatus(mintStatus, `UserOperation sent: ${userOpHash.slice(0, 10)}...`, "pending");
                
                // 4. Wait for completion (simplified for demo)
                // In a real implementation, you would poll for receipt
                await new Promise(resolve => setTimeout(resolve, 10000));
                
                updateStatus(mintStatus, "NFT minted with DIY AA! ðŸŽ‰", "connected");
                
                // Reload NFTs
                await loadNFTs();
                
            } catch (error) {
                console.error("DIY AA Error:", error);
                updateStatus(mintStatus, "Error: " + error.message, "error");
            }
        }

        // Switch to Scroll Sepolia
        async function switchToScrollSepolia() {
            try {
                await window.ethereum.request({
                    method: 'wallet_switchEthereumChain',
                    params: [{ chainId: SCROLL_CHAIN_ID }],
                });
            } catch (switchError) {
                if (switchError.code === 4902) {
                    await window.ethereum.request({
                        method: 'wallet_addEthereumChain',
                        params: [{
                            chainId: SCROLL_CHAIN_ID,
                            chainName: SCROLL_CHAIN_NAME,
                            rpcUrls: [SCROLL_RPC_URL],
                            nativeCurrency: {
                                name: 'Ether',
                                symbol: 'ETH',
                                decimals: 18
                            },
                            blockExplorerUrls: ['https://sepolia.scroll.io/']
                        }]
                    });
                } else {
                    throw switchError;
                }
            }
        }

        // Load user's NFTs
        async function loadNFTs() {
            try {
                const address = await signer.getAddress();
                const balance = await nftContract.balanceOf(address);
                
                if (balance > 0) {
                    let html = '';
                    for (let i = 0; i < balance; i++) {
                        html += `
                            <div class="nft-card">
                                <h3>NFT #${i + 1}</h3>
                                <p>Owned by you</p>
                            </div>
                        `;
                    }
                    nftsContainer.innerHTML = html;
                } else {
                    nftsContainer.innerHTML = '<p>No NFTs yet. Mint your first one!</p>';
                }
            } catch (error) {
                console.error("Error loading NFTs:", error);
                nftsContainer.innerHTML = '<p>Error loading NFTs</p>';
            }
        }

        // Helper function to update status
        function updateStatus(element, message, type) {
            element.textContent = message;
            element.className = "status";
            if (type) element.classList.add(type);
        }

        // Initialize network check
        if (typeof window.ethereum !== 'undefined') {
            window.ethereum.on('chainChanged', (chainId) => {
                if (chainId === SCROLL_CHAIN_ID) {
                    networkStatus.textContent = "Connected to Scroll Sepolia";
                    networkIndicator.className = "network-indicator network-connected";
                } else {
                    networkStatus.textContent = "Please switch to Scroll Sepolia";
                    networkIndicator.className = "network-indicator network-disconnected";
                }
            });
        }
    </script>
</body>
</html>